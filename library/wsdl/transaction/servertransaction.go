// Code generated by gowsdl DO NOT EDIT.

package transaction

import (
	"encoding/xml"
	"errors"
	"fmt"
	"net/http"
	"reflect"
	"strings"

	"github.com/adarshsrinivasan/DS_S24/library/common"
)

var wsdl = `<?xml version="1.0" encoding="UTF-8"?>
<definitions xmlns="http://schemas.xmlsoap.org/wsdl/"
			 xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
			 xmlns:tns="http://localhost:50003"
			 targetNamespace="http://localhost:50003">

	<!-- Types -->
	<types>
		<schema xmlns="http://www.w3.org/2001/XMLSchema" targetNamespace="http://localhost:50003">
			<element name="TransactionRequest">
				<complexType>
					<sequence>
						<element name="Name" type="string"/>
						<element name="CreditCardDetails" type="string"/>
						<element name="expiry" type="string"/>
					</sequence>
				</complexType>
			</element>

			<element name="TransactionResponse">
				<complexType>
					<sequence>
						<element name="approved" type="boolean"/>
					</sequence>
				</complexType>
			</element>
		</schema>
	</types>

	<!-- Message -->
	<message name="isTransactionApprovedRequest">
		<part name="parameters" element="tns:TransactionRequest"/>
	</message>

	<message name="isTransactionApprovedResponse">
		<part name="parameters" element="tns:TransactionResponse"/>
	</message>

	<!-- Port Type -->
	<portType name="TransactionServicePortType">
		<operation name="isTransactionApproved">
			<input message="tns:isTransactionApprovedRequest"/>
			<output message="tns:isTransactionApprovedResponse"/>
		</operation>
	</portType>

	<!-- Binding -->
	<binding name="TransactionServiceSOAPBinding" type="tns:TransactionServicePortType">
		<soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
		<operation name="isTransactionApproved">
			<soap:operation soapAction="http://localhost:50003/isTransactionApproved"/>
			<input>
				<soap:body use="literal"/>
			</input>
			<output>
				<soap:body use="literal"/>
			</output>
		</operation>
	</binding>

	<!-- Service -->
	<service name="TransactionService">
		<port name="TransactionServicePort" binding="tns:TransactionServiceSOAPBinding">
			<soap:address location="http://localhost:50003"/>
		</port>
	</service>

</definitions>`

var WSDLUndefinedError = errors.New("Server was unable to process request. --> Object reference not set to an instance of an object.")

type SOAPEnvelopeRequest struct {
	XMLName xml.Name `xml:"http://schemas.xmlsoap.org/soap/envelope/ Envelope"`
	Body    SOAPBodyRequest
}

type SOAPBodyRequest struct {
	XMLName xml.Name `xml:"http://schemas.xmlsoap.org/soap/envelope/ Body"`

	TransactionRequest *TransactionRequest `xml:,omitempty`
}

type SOAPEnvelopeResponse struct {
	XMLName    xml.Name `xml:"soap:Envelope"`
	PrefixSoap string   `xml:"xmlns:soap,attr"`
	PrefixXsi  string   `xml:"xmlns:xsi,attr"`
	PrefixXsd  string   `xml:"xmlns:xsd,attr"`

	Body SOAPBodyResponse
}

func NewSOAPEnvelopResponse() *SOAPEnvelopeResponse {
	return &SOAPEnvelopeResponse{
		PrefixSoap: "http://schemas.xmlsoap.org/soap/envelope/",
		PrefixXsd:  "http://www.w3.org/2001/XMLSchema",
		PrefixXsi:  "http://www.w3.org/2001/XMLSchema-instance",
	}
}

type Fault struct {
	XMLName xml.Name `xml:"SOAP-ENV:Fault"`
	Space   string   `xml:"xmlns:SOAP-ENV,omitempty,attr"`

	Code   string `xml:"faultcode,omitempty"`
	String string `xml:"faultstring,omitempty"`
	Actor  string `xml:"faultactor,omitempty"`
	Detail string `xml:"detail,omitempty"`
}

type SOAPBodyResponse struct {
	XMLName xml.Name `xml:"soap:Body"`
	Fault   *Fault   `xml:",omitempty"`

	TransactionRequest *TransactionResponse `xml:",omitempty"`
}

func (service *SOAPBodyRequest) TransactionRequestFunc(request *TransactionRequest) (*TransactionResponse, error) {
	return &TransactionResponse{
		Approved: common.ReturnTrueWithProbability(90),
	}, nil
}

func (service *SOAPEnvelopeRequest) call(w http.ResponseWriter, r *http.Request) {
	w.Header().Add("Content-Type", "text/xml; charset=utf-8")
	val := reflect.ValueOf(&service.Body).Elem()
	n := val.NumField()
	var field reflect.Value
	var name string
	find := false

	if r.Method == http.MethodGet {
		w.Write([]byte(wsdl))
		return
	}

	resp := NewSOAPEnvelopResponse()
	defer func() {
		if r := recover(); r != nil {
			resp.Body.Fault = &Fault{}
			resp.Body.Fault.Space = "http://schemas.xmlsoap.org/soap/envelope/"
			resp.Body.Fault.Code = "soap:Server"
			resp.Body.Fault.Detail = fmt.Sprintf("%v", r)
			resp.Body.Fault.String = fmt.Sprintf("%v", r)
		}
		xml.NewEncoder(w).Encode(resp)
	}()

	header := r.Header.Get("Content-Type")
	if strings.Index(header, "application/soap+xml") >= 0 {
		panic("Could not find an appropriate Transport Binding to invoke.")
	}

	err := xml.NewDecoder(r.Body).Decode(service)
	if err != nil {
		panic(err)
	}

	for i := 0; i < n; i++ {
		field = val.Field(i)
		name = val.Type().Field(i).Name
		if field.Kind() != reflect.Ptr {
			continue
		}
		if field.IsNil() {
			continue
		}
		if field.IsValid() {
			find = true
			break
		}
	}

	if !find {
		panic(WSDLUndefinedError)
	} else {
		m := val.Addr().MethodByName(name + "Func")
		if !m.IsValid() {
			panic(WSDLUndefinedError)
		}

		vals := m.Call([]reflect.Value{field})
		if vals[1].IsNil() {
			reflect.ValueOf(&resp.Body).Elem().FieldByName(name).Set(vals[0])
		} else {
			panic(vals[1].Interface())
		}
	}

}

func Endpoint(w http.ResponseWriter, r *http.Request) {
	request := SOAPEnvelopeRequest{}
	request.call(w, r)
}
